<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>제품 공정 플로우 차트 시뮬레이터</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@404&display=swap" rel="stylesheet">
    <!-- Mermaid.js CDN for flowchart rendering -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>
    <!-- html2canvas CDN for image export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f3f4f6; /* Light gray background */
            color: #333;
        }
        /* Custom styles for drag-and-drop and mermaid */
        .drag-handle {
            cursor: grab;
            margin-right: 0.5rem;
            font-size: 1.2rem;
            color: #6b7280;
        }
        .dragging {
            opacity: 0.5;
            border: 2px dashed #60a5fa;
        }
        /* Mermaid specific styling (can be overridden by theme or custom CSS) */
        .mermaid {
            background-color: #ffffff;
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        /* Custom styling for Mermaid nodes based on selected color */
        .mermaid-node-fill {
            fill: var(--node-bg-color, #3b82f6); /* Default blue */
        }
        .mermaid-node-stroke {
            stroke: var(--node-border-color, #1d4ed8); /* Default dark blue */
        }
        .mermaid-text-fill {
            fill: var(--node-text-color, #ffffff); /* Default white */
        }
        /* Adjusted memo input styles for better visual separation */
        .memo-container {
            width: calc(100% - 1.5rem); /* Adjust width considering padding */
            background-color: #f8fafc; /* bg-blue-50 like */
            border: 1px solid #cbd5e1; /* border-gray-300 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 0.5rem;
            margin-top: 0.75rem; /* mt-3 */
            margin-left: 1.5rem; /* Align with checkbox text */
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); /* subtle inner shadow */
        }
        .memo-input {
            width: 100%;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem; /* leading-tight */
            background-color: transparent; /* No background */
            border: none; /* No border */
            outline: none; /* No outline on focus */
            resize: none; /* Disable manual resize */
            padding: 0; /* Remove default padding */
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div id="main-content-area" class="max-w-7xl mx-auto bg-white rounded-xl shadow-lg p-6 md:p-8">
        <h1 class="text-3xl md:text-4xl font-extrabold text-center text-gray-800 mb-4">
            제품 공정 플로우 차트 시뮬레이터
        </h1>

        <div class="text-center text-sm text-gray-600 mb-4">
            <span class="font-semibold">현재 사용자 ID:</span> <span id="user-id-display" class="font-mono text-blue-700 break-all">로딩 중...</span>
            <p class="text-xs text-gray-500 mt-1">이 ID를 통해 Firestore에서 여러분의 데이터를 구분합니다.</p>
        </div>

        <!-- Product Name, Factory Selection, Packaging Type, Packaging Unit, Sterilization Type, 1 Batch, Daily Capacity -->
        <div class="mb-8 text-center flex flex-col gap-4">
            <!-- Row 1: Product Name, Factory, Packaging Type -->
            <div class="flex flex-col md:flex-row items-center justify-center gap-4">
                <div class="flex flex-col items-center">
                    <label for="product-name-input" class="block text-xl font-semibold text-gray-700 mb-2">제품명:</label>
                    <input type="text" id="product-name-input" placeholder="제품 이름을 입력하세요..."
                           class="w-full max-w-xs p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-center text-lg">
                </div>
                <div class="flex flex-col items-center">
                    <label for="factory-select" class="block text-xl font-semibold text-gray-700 mb-2">공장 구분:</label>
                    <select id="factory-select"
                            class="w-full max-w-xs p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-center text-lg bg-white">
                        <option value="">-- 공장 선택 --</option>
                        <option value="신선">신선</option>
                        <option value="완전">완전</option>
                        <option value="진푸드">진푸드</option>
                    </select>
                </div>
                <div class="flex flex-col items-center">
                    <label for="packaging-type-select" class="block text-xl font-semibold text-gray-700 mb-2">포장 유형:</label>
                    <select id="packaging-type-select"
                            class="w-full max-w-xs p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-center text-lg bg-white">
                        <option value="">-- 포장 유형 선택 --</option>
                        <option value="페일통(BIB)">페일통(BIB)</option>
                        <option value="드럼">드럼</option>
                        <option value="소포장(필름)">소포장(필름)</option>
                        <option value="로터리파우치">로터리파우치</option>
                        <option value="벌크파우치">벌크파우치</option>
                        <option value="튜브">튜브</option>
                        <option value="유리병">유리병</option>
                    </select>
                </div>
            </div>
            <!-- Row 2: Packaging Unit, Sterilization Type, 1 Batch, Daily Capacity -->
            <div class="flex flex-col md:flex-row items-center justify-center gap-4">
                <div id="packaging-unit-section" class="flex flex-col items-center">
                    <label for="packaging-unit-select" class="block text-xl font-semibold text-gray-700 mb-2">포장 단위:</label>
                    <select id="packaging-unit-select"
                            class="w-full max-w-xs p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-center text-lg bg-white">
                        <option value="">-- 단위 선택 --</option>
                        <!-- Options for packaging units will be dynamically added/removed by JavaScript -->
                    </select>
                </div>
                <div class="flex flex-col items-center">
                    <label for="sterilization-type-select" class="block text-xl font-semibold text-gray-700 mb-2">살균 유형:</label>
                    <select id="sterilization-type-select"
                            class="w-full max-w-xs p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-center text-lg bg-white">
                        <option value="">-- 살균 유형 선택 --</option>
                        <option value="핫필">핫필</option>
                        <option value="콜드필">콜드필</option>
                        <option value="레트로트">레트로트</option>
                        <option value="UHT">UHT</option>
                        <option value="튜블러">튜블러</option>
                    </select>
                </div>
                <!-- Updated: 1 배치 type changed to text -->
                <div class="flex flex-col items-center">
                    <label for="one-batch-input" class="block text-xl font-semibold text-gray-700 mb-2">1 배치:</label>
                    <input type="text" id="one-batch-input" placeholder="배치량 입력"
                           class="w-full max-w-xs p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-center text-lg">
                </div>
                <!-- Updated: 1일 캐파 type changed to text -->
                <div class="flex flex-col items-center">
                    <label for="daily-capacity-input" class="block text-xl font-semibold text-gray-700 mb-2">1일 캐파:</label>
                    <input type="text" id="daily-capacity-input" placeholder="일일 생산량 입력"
                           class="w-full max-w-xs p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-center text-lg">
                </div>
            </div>
            <!-- New: Sub-materials Section -->
            <div id="sub-materials-section" class="flex flex-col items-center justify-center gap-2 mt-4 p-4 border border-gray-300 rounded-lg bg-gray-50 hidden w-full">
                <label class="block text-xl font-semibold text-gray-700 mb-2">부자재:</label>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-2 text-gray-700 text-lg">
                    <p><strong>유리병:</strong> 4000ea</p>
                    <p><strong>캡:</strong> 4000ea</p>
                    <p><strong>캡 디자인시:</strong> 100,000ea</p>
                    <p><strong>안전 스티커:</strong> 2000ea (30원 내외)</p>
                    <p><strong>라벨:</strong> 2000ea (70원 내외)</p>
                </div>
            </div>
        </div>

        <!-- Photos Section -->
        <div class="mb-8 flex flex-col md:flex-row items-start justify-center gap-6">
            <div class="flex flex-col items-center w-full md:w-1/3">
                <label id="product-image-url-label" for="product-image-url-input" class="block text-xl font-semibold text-gray-700 mb-2">제품 사진 (URL 또는 드래그 & 드롭):</label>
                <input type="url" id="product-image-url-input" placeholder="제품 사진 URL을 입력하거나 파일을 여기에 드롭하세요."
                       class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-center text-base mb-3">
                <div id="product-image-drop-zone" class="relative w-48 h-48 flex items-center justify-center border-2 border-dashed border-gray-300 rounded-lg bg-gray-100 cursor-pointer hover:border-blue-500 transition duration-200">
                    <img id="product-image-display" src="https://placehold.co/200x200/e0e0e0/000000?text=제품사진" alt="제품 사진"
                         class="w-full h-full object-contain rounded-lg"
                         onerror="this.onerror=null;this.src='https://placehold.co/200x200/e0e0e0/000000?text=이미지없음';">
                    <p class="absolute text-gray-500 text-sm pointer-events-none">여기에 이미지 드롭</p>
                </div>
                <label for="product-image-description" class="block text-lg font-semibold text-gray-700 mt-4 mb-2">제품 사진 설명 (100자 이내):</label>
                <textarea id="product-image-description" maxlength="100" rows="3"
                          placeholder="제품 사진에 대한 설명을 100자 이내로 입력하세요."
                          class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-sm resize-none"></textarea>
            </div>

            <!-- Korean Label Photo Section -->
            <div class="flex flex-col items-center w-full md:w-1/3">
                <label id="korean-label-image-url-label" for="korean-label-image-url-input" class="block text-xl font-semibold text-gray-700 mb-2">한글 라벨 사진 (URL 또는 드래그 & 드롭):</label>
                <input type="url" id="korean-label-image-url-input" placeholder="한글 라벨 사진 URL을 입력하거나 파일을 여기에 드롭하세요."
                       class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-center text-base mb-3">
                <div id="korean-label-image-drop-zone" class="relative w-48 h-48 flex items-center justify-center border-2 border-dashed border-gray-300 rounded-lg bg-gray-100 cursor-pointer hover:border-blue-500 transition duration-200">
                    <img id="korean-label-image-display" src="https://placehold.co/200x200/e0e0e0/000000?text=라벨사진" alt="한글 라벨 사진"
                         class="w-full h-full object-contain rounded-lg"
                         onerror="this.onerror=null;this.src='https://placehold.co/200x200/e0e0e0/000000?text=이미지없음';">
                    <p class="absolute text-gray-500 text-sm pointer-events-none">여기에 이미지 드롭</p>
                </div>
                <label for="korean-label-image-description" class="block text-lg font-semibold text-gray-700 mt-4 mb-2">라벨 사진 설명 (100자 이내):</label>
                <textarea id="korean-label-image-description" maxlength="100" rows="3"
                          placeholder="라벨 사진에 대한 설명을 100자 이내로 입력하세요."
                          class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-sm resize-none"></textarea>
            </div>

            <div class="flex flex-col items-center w-full md:w-1/3">
                <label id="cooking-image-url-label" for="cooking-image-url-input" class="block text-xl font-semibold text-gray-700 mb-2">조리 사진 (URL 또는 드래그 & 드롭):</label>
                <input type="url" id="cooking-image-url-input" placeholder="조리 사진 URL을 입력하거나 파일을 여기에 드롭하세요."
                       class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-center text-base mb-3">
                <div id="cooking-image-drop-zone" class="relative w-48 h-48 flex items-center justify-center border-2 border-dashed border-gray-300 rounded-lg bg-gray-100 cursor-pointer hover:border-blue-500 transition duration-200">
                    <img id="cooking-image-display" src="https://placehold.co/200x200/e0e0e0/000000?text=조리사진" alt="조리 사진"
                         class="w-full h-full object-contain rounded-lg"
                         onerror="this.onerror=null;this.src='https://placehold.co/200x200/e0e0e0/000000?text=이미지없음';">
                    <p class="absolute text-gray-500 text-sm pointer-events-none">여기에 이미지 드롭</p>
                </div>
                <label for="cooking-image-description" class="block text-lg font-semibold text-gray-700 mt-4 mb-2">조리 사진 설명 (100자 이내):</label>
                <textarea id="cooking-image-description" maxlength="100" rows="3"
                          placeholder="조리 사진에 대한 설명을 100자 이내로 입력하세요."
                          class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 text-sm resize-none"></textarea>
            </div>
        </div>

        <div class="flex flex-col md:flex-row gap-8">
            <!-- Left Panel: Process Definition & Controls -->
            <div class="md:w-1/2 bg-gray-50 p-6 rounded-lg shadow-inner flex flex-col space-y-6">
                <h2 class="text-2xl font-bold text-gray-700 mb-4">공정 정의 및 관리</h2>

                <!-- Add New Process -->
                <div class="flex gap-2">
                    <input type="text" id="new-process-input" placeholder="새로운 공정 이름을 입력하세요..."
                           class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200"
                           onkeyup="if(event.key === 'Enter') addProcess()">
                    <button onclick="addProcess()"
                            class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-5 rounded-lg shadow-md transition duration-200 transform hover:scale-105">
                        <span class="hidden md:inline">+ 공정 추가</span>
                        <span class="md:hidden">+</span>
                    </button>
                </div>

                <!-- Process List -->
                <div class="bg-white p-4 rounded-lg shadow-md flex-grow overflow-y-auto max-h-96">
                    <ul id="process-list" class="space-y-3">
                        <!-- Process items will be rendered here by JavaScript -->
                    </ul>
                    <p id="no-processes-message" class="text-gray-500 text-center mt-4 hidden">
                        아직 공정이 없습니다. 새로운 공정을 추가해주세요.
                    </p>
                </div>

                <!-- Action Buttons -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <button onclick="saveConfiguration()"
                            class="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-5 rounded-lg shadow-md transition duration-200 transform hover:scale-105">
                        <span class="hidden md:inline">현재 구성 저장</span>
                        <span class="md:hidden">저장</span>
                    </button>
                    <button onclick="showLoadConfigModal()"
                            class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 px-5 rounded-lg shadow-md transition duration-200 transform hover:scale-105">
                        <span class="hidden md:inline">구성 불러오기</span>
                        <span class="md:hidden">불러오기</span>
                    </button>
                    <div class="col-span-full flex items-center gap-2">
                        <label for="node-color" class="text-gray-700 font-medium">노드 색상:</label>
                        <input type="color" id="node-color" value="#3b82f6"
                               class="w-10 h-10 rounded-md border-2 border-gray-300 cursor-pointer"
                               onchange="updateFlowchartColors(this.value)">
                    </div>
                    <button onclick="exportFlowchartAsImage()"
                            class="col-span-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-5 rounded-lg shadow-md transition duration-200 transform hover:scale-105">
                        <span class="hidden md:inline">플로우 차트 이미지로 내보내기</span>
                        <span class="md:hidden">이미지 내보내기</span>
                    </button>
                </div>
                <p id="status-message" class="text-sm text-center mt-2 text-gray-600"></p>
            </div>

            <!-- Right Panel: Flowchart Display -->
            <div class="md:w-1/2 bg-white p-6 rounded-lg shadow-lg flex flex-col items-center justify-center">
                <h2 class="text-2xl font-bold text-gray-700 mb-4">플로우 차트 시각화</h2>
                <div id="flowchart-display" class="w-full h-full min-h-[300px] flex items-center justify-center text-gray-500 text-lg">
                    <!-- Flowchart will be rendered here by Mermaid.js -->
                    <p>공정을 추가하고 선택하여 플로우 차트를 확인하세요.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Configuration Modal -->
    <div id="load-config-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 class="text-xl font-bold mb-4">구성 불러오기</h3>
            <div class="mb-4">
                <label for="saved-configs-select" class="block text-gray-700 text-sm font-bold mb-2">저장된 구성 선택:</label>
                <select id="saved-configs-select" class="shadow border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                    <!-- Options will be populated by JS -->
                </select>
            </div>
            <div class="flex justify-end gap-2">
                <button id="load-selected-config-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-200">불러오기</button>
                <button id="delete-selected-config-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition duration-200">삭제</button>
                <button id="cancel-load-config-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded transition duration-200">취소</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase SDK Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, collection, query, onSnapshot, deleteDoc, getDocs, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"; // getDoc 추가 확인

        // Firebase Initialization (using global variables provided by Canvas environment)
        // __firebase_config is a JSON string, so parse it.
        // NOTE: If running this code locally (not in Canvas), you MUST replace this with your actual Firebase project config.
        // Get your config from Firebase Console -> Project settings -> Your apps -> Web app -> Config
        const firebaseConfig = {
  apiKey: "AIzaSyCteISMGfhpktpQcYn-xe3qCYQ-AX-JJUI",
  authDomain: "new-list-7a265.firebaseapp.com",
  projectId: "new-list-7a265",
  storageBucket: "new-list-7a265.firebasestorage.app",
  messagingSenderId: "274215892545",
  appId: "1:274215892545:web:a761188b074651b93e38c0",
  measurementId: "G-LMW04J4XDK"
};
        // Canvas 환경이 아닌 로컬에서 실행할 때 필요한 앱 ID 및 초기 인증 토큰 (일반적으로 null)
        // 이 `appId`는 Firestore 데이터 경로 `/artifacts/{appId}/public/data/`에 사용됩니다.
        // Canvas 환경에서 실행 시 __app_id와 __initial_auth_token 변수가 자동으로 제공됩니다.
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth, userId = null;

        // Mermaid.js configuration (initialized after HTML load)
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default', // Using default theme, will override colors via CSS variables
            securityLevel: 'loose', // Allow custom styling
            flowchart: {
                curve: 'basis' // Smooth curves for connections
            }
        });

        // Array to store process data
        let processes = [];
        let productName = '';
        let selectedFactory = '';
        let selectedPackagingType = '';
        let selectedPackagingUnit = '';
        let selectedSterilizationType = '';
        let oneBatchAmount = '';
        let dailyCapacity = '';
        let productImageUrl = '';
        let koreanLabelImageUrl = '';
        let cookingImageUrl = '';
        let productImageDescription = '';
        let koreanLabelImageDescription = '';
        let cookingImageDescription = '';
        let draggedItem = null; // Stores the item being dragged

        // DOM element references
        const userIdDisplay = document.getElementById('user-id-display');
        const productNameInput = document.getElementById('product-name-input');
        const factorySelect = document.getElementById('factory-select');
        const packagingTypeSelect = document.getElementById('packaging-type-select');
        const packagingUnitSelect = document.getElementById('packaging-unit-select');
        const sterilizationTypeSelect = document.getElementById('sterilization-type-select');
        const oneBatchInput = document.getElementById('one-batch-input');
        const dailyCapacityInput = document.getElementById('daily-capacity-input');
        const productImageUrlInput = document.getElementById('product-image-url-input');
        const productImageDisplay = document.getElementById('product-image-display');
        const koreanLabelImageUrlInput = document.getElementById('korean-label-image-url-input');
        const koreanLabelImageDisplay = document.getElementById('korean-label-image-display');
        const cookingImageUrlInput = document.getElementById('cooking-image-url-input');
        const cookingImageDisplay = document.getElementById('cooking-image-display');
        const productImageDescriptionInput = document.getElementById('product-image-description');
        const koreanLabelImageDescriptionInput = document.getElementById('korean-label-image-description');
        const cookingImageDescriptionInput = document.getElementById('cooking-image-description');
        const processListElement = document.getElementById('process-list');
        const newProcessInput = document.getElementById('new-process-input');
        const flowchartDisplay = document.getElementById('flowchart-display');
        const statusMessage = document.getElementById('status-message');
        const noProcessesMessage = document.getElementById('no-processes-message');
        const nodeColorInput = document.getElementById('node-color');

        // New DOM references for image drop zones and their text overlays
        const productImageDropZone = document.getElementById('product-image-drop-zone');
        const koreanLabelImageDropZone = document.getElementById('korean-label-image-drop-zone');
        const cookingImageDropZone = document.getElementById('cooking-image-drop-zone');
        const productImageDropText = productImageDropZone.querySelector('p');
        const koreanLabelImageDropText = koreanLabelImageDropZone.querySelector('p');
        const cookingImageDropText = cookingImageDropZone.querySelector('p');
        const productImageUrlLabel = document.getElementById('product-image-url-label');
        const koreanLabelImageUrlLabel = document.getElementById('korean-label-image-url-label');
        const cookingImageUrlLabel = document.getElementById('cooking-image-url-label');

        // New DOM reference for Sub-materials section
        const subMaterialsSection = document.getElementById('sub-materials-section');


        // Modal DOM elements
        const loadConfigModal = document.getElementById('load-config-modal');
        const savedConfigsSelect = document.getElementById('saved-configs-select');
        const loadSelectedConfigBtn = document.getElementById('load-selected-config-btn');
        const cancelLoadConfigBtn = document.getElementById('cancel-load-config-btn');
        const deleteSelectedConfigBtn = document.getElementById('delete-selected-config-btn');

        // Initial setup and Firebase authentication
        document.addEventListener('DOMContentLoaded', async () => {
            // Store original placeholder src for fallback
            productImageDisplay.dataset.placeholderSrc = productImageDisplay.src;
            koreanLabelImageDisplay.dataset.placeholderSrc = koreanLabelImageDisplay.src;
            cookingImageDisplay.dataset.placeholderSrc = cookingImageDisplay.src;

            // Initialize Firebase App
            // Check if firebaseConfig is valid (not empty and not placeholder)
            if (firebaseConfig.apiKey && firebaseConfig.apiKey !== "YOUR_API_KEY" && firebaseConfig.authDomain && firebaseConfig.projectId && firebaseConfig.appId) {
                try {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);

                    // Authenticate user
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                    userId = auth.currentUser.uid;
                    userIdDisplay.textContent = userId;
                    showMessage('Firebase 인증 성공!', 'success');

                    // 디버깅용 로그: db, auth, userId 객체 상태 확인
                    console.log("Firebase 초기화 완료. db:", db, "auth:", auth, "userId:", userId);


                    // Load the current working configuration on app start
                    loadCurrentWorkingConfig();

                } catch (error) {
                    console.error("Firebase 초기화 또는 인증 실패:", error);
                    userIdDisplay.textContent = '인증 실패';
                    showMessage('Firebase 초기화 또는 인증 실패: ' + error.message + ' (Firebase 콘솔 설정을 확인해주세요!)', 'error');
                    db = null; // Prevent further Firebase operations
                    auth = null;
                }
            } else {
                userIdDisplay.textContent = 'Firebase 설정 필요';
                showMessage('Firebase 설정이 올바르지 않습니다. (Firebase Console에서 API 키를 확인하고 코드에 붙여넣어주세요!)', 'info');
                db = null; // Prevent attempts to use db/auth
                auth = null;
            }

            // Load saved node color
            const savedColor = localStorage.getItem('flowchartNodeColor');
            if (savedColor) {
                nodeColorInput.value = savedColor;
                updateFlowchartColors(savedColor);
            }
            // Initial render of process list (might be empty)
            renderProcessList();
        });

        // Event Listeners for input changes (trigger auto-save)
        productNameInput.addEventListener('input', (event) => {
            productName = event.target.value.trim();
            saveCurrentWorkingConfig(); // Auto-save
        });

        factorySelect.addEventListener('change', (event) => {
            selectedFactory = event.target.value;
            saveCurrentWorkingConfig(); // Auto-save
        });

        // Event Listener for packaging type select
        packagingTypeSelect.addEventListener('change', (event) => {
            selectedPackagingType = event.target.value;
            // Update packaging unit options based on selected packaging type
            updatePackagingUnitOptions(selectedPackagingType);
            saveCurrentWorkingConfig(); // Auto-save
        });

        // Event Listener for packaging unit select
        packagingUnitSelect.addEventListener('change', (event) => {
            selectedPackagingUnit = event.target.value;
            // Add specific logic for 430g or 600g when selected
            if (selectedPackagingUnit === '430g' || selectedPackagingUnit === '600g') {
                oneBatchInput.value = '약 1,000kg ~1,500kg';
                dailyCapacityInput.value = '약 8~10배치 16,000~20,000개';
            } else if (selectedPackagingUnit === '200g' || selectedPackagingUnit === '240g') { // Added 200g, 240g logic
                oneBatchInput.value = '500kg~700kg';
                dailyCapacityInput.value = '5배치 10,000ea 이상';
            }
            else {
                oneBatchInput.value = ''; // Clear if other unit is selected
                dailyCapacityInput.value = '';
            }
            saveCurrentWorkingConfig(); // Auto-save
        });

        // Event Listener for sterilization type select
        sterilizationTypeSelect.addEventListener('change', (event) => {
            selectedSterilizationType = event.target.value;
            saveCurrentWorkingConfig(); // Auto-save
        });

        // Event Listeners for 1 Batch and Daily Capacity inputs
        oneBatchInput.addEventListener('input', (event) => {
            oneBatchAmount = event.target.value.trim();
            saveCurrentWorkingConfig(); // Auto-save
        });

        dailyCapacityInput.addEventListener('input', (event) => {
            dailyCapacity = event.target.value.trim();
            saveCurrentWorkingConfig(); // Auto-save
        });

        // Event Listeners for image URLs (adjusted to use updateImageDisplay)
        productImageUrlInput.addEventListener('input', (event) => {
            productImageUrl = event.target.value.trim();
            updateImageDisplay(productImageDisplay, productImageUrlInput, productImageUrl, productImageDropText);
            saveCurrentWorkingConfig(); // Auto-save
        });

        koreanLabelImageUrlInput.addEventListener('input', (event) => { // New event listener for label image URL
            koreanLabelImageUrl = event.target.value.trim();
            updateImageDisplay(koreanLabelImageDisplay, koreanLabelImageUrlInput, koreanLabelImageUrl, koreanLabelImageDropText);
            saveCurrentWorkingConfig(); // Auto-save
        });

        cookingImageUrlInput.addEventListener('input', (event) => {
            cookingImageUrl = event.target.value.trim();
            updateImageDisplay(cookingImageDisplay, cookingImageUrlInput, cookingImageUrl, cookingImageDropText);
            saveCurrentWorkingConfig(); // Auto-save
        });

        // Event Listeners for image descriptions
        productImageDescriptionInput.addEventListener('input', (event) => {
            productImageDescription = event.target.value;
            saveCurrentWorkingConfig(); // Auto-save
        });

        koreanLabelImageDescriptionInput.addEventListener('input', (event) => { // New event listener for label image description
            koreanLabelImageDescription = event.target.value;
            saveCurrentWorkingConfig(); // Auto-save
        });

        cookingImageDescriptionInput.addEventListener('input', (event) => {
            cookingImageDescription = event.target.value;
            saveCurrentWorkingConfig(); // Auto-save
        });

        // Attach drag and drop listeners for image zones
        productImageDropZone.addEventListener('dragover', handleImageDragOver);
        productImageDropZone.addEventListener('dragleave', handleImageDragLeave);
        productImageDropZone.addEventListener('drop', handleImageDrop);

        koreanLabelImageDropZone.addEventListener('dragover', handleImageDragOver); // New drag drop listener for label image
        koreanLabelImageDropZone.addEventListener('dragleave', handleImageDragLeave);
        koreanLabelImageDropZone.addEventListener('drop', handleImageDrop);

        cookingImageDropZone.addEventListener('dragover', handleImageDragOver);
        cookingImageDropZone.addEventListener('dragleave', handleImageDragLeave);
        cookingImageDropZone.addEventListener('drop', handleImageDrop);

        // Ensure the image onerror handler is robust
        productImageDisplay.onerror = function() {
            this.src = this.dataset.placeholderSrc; // Fallback to stored placeholder
            productImageDropText.classList.remove('hidden'); // Show text on error
        };
        koreanLabelImageDisplay.onerror = function() { // New onerror for label image
            this.src = this.dataset.placeholderSrc;
            koreanLabelImageDropText.classList.remove('hidden');
        };
        cookingImageDisplay.onerror = function() {
            this.src = this.dataset.placeholderSrc; // Fallback to stored placeholder
            cookingImageDropText.classList.remove('hidden'); // Show text on error
        };


        // Modal event listeners
        cancelLoadConfigBtn.addEventListener('click', () => {
            loadConfigModal.classList.add('hidden');
        });

        loadSelectedConfigBtn.addEventListener('click', async () => {
            const configName = savedConfigsSelect.value;
            if (configName) {
                await loadNamedConfiguration(configName); // Await loadConfiguration
                loadConfigModal.classList.add('hidden');
            } else {
                showMessage('불러올 구성을 선택해주세요.', 'error');
            }
        });

        deleteSelectedConfigBtn.addEventListener('click', async () => {
            const configName = savedConfigsSelect.value;
            if (configName) {
                await deleteNamedConfiguration(configName); // Await deleteConfiguration
            } else {
                showMessage('삭제할 구성을 선택해주세요.', 'error');
            }
        });

        /**
         * Renders the process list and sets up drag-and-drop events.
         */
        function renderProcessList() {
            processListElement.innerHTML = ''; // Clear existing list
            if (processes.length === 0) {
                noProcessesMessage.classList.remove('hidden');
            } else {
                noProcessesMessage.classList.add('hidden');
            }

            processes.forEach(process => {
                const li = document.createElement('li');
                li.id = `process-${process.id}`;
                li.className = 'flex flex-wrap items-start bg-white p-3 rounded-lg shadow-sm border border-gray-200 text-gray-800';
                li.draggable = true; // Make li directly draggable

                const headerDiv = document.createElement('div');
                headerDiv.className = 'flex items-center w-full';
                // headerDiv.draggable = true; // Removed draggable from headerDiv

                // Drag handle
                const dragHandle = document.createElement('span');
                dragHandle.className = 'drag-handle text-gray-500 hover:text-gray-700 transition duration-150';
                dragHandle.innerHTML = '&#9776;';
                headerDiv.appendChild(dragHandle);

                // Checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = process.selected;
                checkbox.className = 'mr-3 h-5 w-5 text-blue-600 rounded border-gray-300 focus:ring-blue-500';
                checkbox.onchange = () => toggleProcess(process.id);
                headerDiv.appendChild(checkbox);

                // Process name (editable)
                const processNameSpan = document.createElement('span');
                processNameSpan.className = 'flex-grow font-medium text-lg';
                processNameSpan.textContent = process.name;
                processNameSpan.ondblclick = () => makeEditable(processNameSpan, process.id, 'name');
                headerDiv.appendChild(processNameSpan);

                // Edit button
                const editButton = document.createElement('button');
                editButton.className = 'ml-2 p-2 rounded-full hover:bg-yellow-100 text-yellow-600 transition duration-150';
                editButton.innerHTML = '✏️';
                editButton.onclick = () => makeEditable(processNameSpan, process.id, 'name');
                headerDiv.appendChild(editButton);

                // Delete button
                const deleteButton = document.createElement('button');
                deleteButton.className = 'ml-2 p-2 rounded-full hover:bg-red-100 text-red-600 transition duration-150';
                deleteButton.innerHTML = '❌';
                deleteButton.onclick = () => deleteProcess(process.id);
                headerDiv.appendChild(deleteButton);

                li.appendChild(headerDiv);

                // Memo container and textarea
                const memoContainer = document.createElement('div');
                memoContainer.className = 'memo-container w-full';
                const memoTextarea = document.createElement('textarea');
                memoTextarea.id = `memo-${process.id}`;
                memoTextarea.className = 'memo-input';
                memoTextarea.placeholder = '간략한 메모 (100자 이내)...';
                memoTextarea.maxLength = 100;
                memoTextarea.rows = 1;
                memoTextarea.value = process.memo || '';
                memoTextarea.addEventListener('input', (event) => {
                    const currentProcess = processes.find(p => p.id === process.id);
                    if (currentProcess) {
                        currentProcess.memo = event.target.value;
                        // Save to Firestore immediately for real-time update
                        saveCurrentWorkingConfig();
                    }
                });
                memoContainer.appendChild(memoTextarea);
                li.appendChild(memoContainer);

                // Drag and drop event listeners for the entire li element
                li.addEventListener('dragstart', handleDragStart);
                li.addEventListener('dragover', handleDragOver);
                li.addEventListener('drop', handleDrop);
                li.addEventListener('dragenter', handleDragEnter);
                li.addEventListener('dragleave', handleDragLeave);
                li.addEventListener('dragend', handleDragEnd);

                processListElement.appendChild(li);
            });

            renderFlowchart();
        }

        /**
         * Makes the process name editable.
         * @param {HTMLElement} spanElement - The span element displaying the process name
         * @param {number} id - Process ID
         * @param {string} field - 'name' or 'memo'
         */
        function makeEditable(spanElement, id, field) {
            const currentProcess = processes.find(p => p.id === id);
            if (!currentProcess) return;

            const currentValue = currentProcess[field];
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentValue;
            input.className = 'flex-grow p-1 border border-blue-300 rounded-md focus:ring-1 focus:ring-blue-400';

            input.onkeyup = async (event) => { // Make async to await Firestore save
                if (event.key === 'Enter') {
                    if (field === 'name') {
                        await updateProcessName(id, input.value); // Await update
                    }
                    spanElement.textContent = input.value;
                    spanElement.replaceWith(spanElement);
                    renderProcessList();
                }
            };
            input.onblur = async () => { // Make async to await Firestore save
                // Only update if value actually changed on blur
                if (input.value.trim() !== currentValue) {
                     if (field === 'name') {
                        await updateProcessName(id, input.value); // Await update
                    }
                }
                spanElement.textContent = currentValue;
                spanElement.replaceWith(spanElement);
                renderProcessList();
            };

            spanElement.replaceWith(input);
            input.focus();
        }

        /**
         * Updates the process name and saves to Firestore.
         * @param {number} id - Process ID
         * @param {string} newName - New process name
         */
        async function updateProcessName(id, newName) {
            const process = processes.find(p => p.id === id);
            if (process) {
                process.name = newName.trim();
                renderFlowchart();
                await saveCurrentWorkingConfig(); // Save to Firestore
            }
        }

        /**
         * Adds a new process and saves to Firestore.
         */
        async function addProcess() {
            const name = newProcessInput.value.trim();
            if (name) {
                const newId = processes.length > 0 ? Math.max(...processes.map(p => p.id)) + 1 : 1;
                processes.push({ id: newId, name: name, selected: true, memo: '' });
                newProcessInput.value = '';
                console.log("공정 추가됨:", processes); // Debugging log
                renderProcessList();
                await saveCurrentWorkingConfig(); // Save to Firestore
                showMessage('공정이 추가되었습니다!', 'success');
            } else {
                showMessage('공정 이름을 입력해주세요.', 'error');
            }
        }

        /**
         * Toggles the selected state of a process and saves to Firestore.
         * @param {number} id - Process ID
         */
        async function toggleProcess(id) {
            const process = processes.find(p => p.id === id);
            if (process) {
                process.selected = !process.selected;
                renderFlowchart();
                await saveCurrentWorkingConfig(); // Save to Firestore
            }
        }

        /**
         * Deletes a process and saves to Firestore.
         * @param {number} id - Process ID
         */
        async function deleteProcess(id) {
            processes = processes.filter(p => p.id !== id);
            renderProcessList();
            await saveCurrentWorkingConfig(); // Save to Firestore
            showMessage('공정이 삭제되었습니다.', 'success');
        }

        /**
         * Renders the flowchart using Mermaid.js.
         */
        function renderFlowchart() {
            const selectedProcesses = processes.filter(p => p.selected);

            if (selectedProcesses.length === 0) {
                flowchartDisplay.innerHTML = '<p class="text-gray-500 text-lg">체크된 공정이 없습니다. 공정을 선택해주세요.</p>';
                return;
            }

            let mermaidCode = 'graph TD;\n'; // TD: Top Down
            selectedProcesses.forEach((process, index) => {
                const nodeText = process.name + (process.memo ? ' — ' + process.memo : '');
                mermaidCode += `    ${process.id}("${nodeText}");\n`;
                if (index < selectedProcesses.length - 1) {
                    const nextProcess = selectedProcesses[index + 1];
                    mermaidCode += `    ${process.id} --> ${nextProcess.id};\n`;
                }
            });

            flowchartDisplay.innerHTML = `<pre class="mermaid">${mermaidCode}</pre>`;
            try {
                mermaid.init(undefined, flowchartDisplay.querySelector('.mermaid'));
            } catch (error) {
                console.error("Mermaid rendering error:", error);
                flowchartDisplay.innerHTML = `<p class="text-red-500">플로우 차트 렌더링에 실패했습니다. 오류: ${error.message}</p>`;
            }
        }

        /**
         * Updates the flowchart node colors.
         * @param {string} color - Selected color (HEX code)
         */
        function updateFlowchartColors(color) {
            document.documentElement.style.setProperty('--node-bg-color', color);
            const darkerColor = darkenColor(color, 20);
            document.documentElement.style.setProperty('--node-border-color', darkerColor);
            const textColor = getContrastColor(color);
            document.documentElement.style.setProperty('--node-text-color', textColor);

            localStorage.setItem('flowchartNodeColor', color);
            renderFlowchart();
        }

        function darkenColor(hexColor, percent) {
            let f = parseInt(hexColor.slice(1), 16),
                t = percent < 0 ? 0 : 255,
                p = percent < 0 ? percent * -1 : percent,
                R = f >> 16,
                G = (f >> 8) & 0x00ff,
                B = f & 0x0000ff;
            return (
                "#" +
                (
                    0x1000000 +
                    (Math.round((t - R) * p) + R) * 0x10000 +
                    (Math.round((t - G) * p) + G) * 100 +
                    (Math.round((t - B) * p) + B)
                )
                .toString(16)
                .slice(1)
            );
        }

        function getContrastColor(hexColor) {
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5 ? '#000000' : '#ffffff';
        }

        /**
         * Updates the options in the packaging unit select based on packaging type.
         * Also controls the visibility of the sub-materials section and clears capacity fields if not 430g/600g.
         * @param {string} type - The selected packaging type.
         * @param {string} unitToSelect - The packaging unit to select (for loading).
         */
        function updatePackagingUnitOptions(type, unitToSelect = '') {
            while (packagingUnitSelect.options.length > 1) {
                packagingUnitSelect.remove(1);
            }
            selectedPackagingUnit = '';
            packagingUnitSelect.value = '';

            if (type === '유리병') {
                subMaterialsSection.classList.remove('hidden');
                const units = ["200g", "240g", "430g", "600g"];
                units.forEach(unit => {
                    const option = document.createElement('option');
                    option.value = unit;
                    option.textContent = unit;
                    packagingUnitSelect.appendChild(option);
                });
                if (unitToSelect && units.includes(unitToSelect)) {
                    packagingUnitSelect.value = unitToSelect;
                    selectedPackagingUnit = unitToSelect;
                    if (unitToSelect === '430g' || unitToSelect === '600g') {
                        oneBatchInput.value = '약 1,000kg ~1,500kg';
                        dailyCapacityInput.value = '약 8~10배치 16,000~20,000개';
                    } else if (unitToSelect === '200g' || unitToSelect === '240g') {
                        oneBatchInput.value = '500kg~700kg';
                        dailyCapacityInput.value = '5배치 10,000ea 이상';
                    }
                    else {
                        oneBatchInput.value = '';
                        dailyCapacityInput.value = '';
                    }
                } else {
                    oneBatchInput.value = '';
                    dailyCapacityInput.value = '';
                }
            } else {
                subMaterialsSection.classList.add('hidden');
                oneBatchInput.value = '';
                dailyCapacityInput.value = '';
            }
        }


        /**
         * Builds a unique config name based on current selections.
         * This is used as a suggested name for explicit saves.
         * @returns {string} The generated config name.
         */
        function generateSuggestedConfigName() {
            let configNameParts = [];
            if (selectedFactory) configNameParts.push(selectedFactory);
            if (productName) configNameParts.push(productName);
            if (selectedPackagingType) configNameParts.push(selectedPackagingType);
            if (selectedPackagingUnit) configNameParts.push(selectedPackagingUnit);
            if (selectedSterilizationType) configNameParts.push(selectedSterilizationType);
            // Clean values for filename to avoid issues with special characters
            const cleanOneBatch = oneBatchAmount.replace(/[^a-zA-Z0-9가-힣]/g, '').trim();
            const cleanDailyCapacity = dailyCapacity.replace(/[^a-zA-Z0-9가-힣]/g, '').trim();
            if (cleanOneBatch) configNameParts.push(`${cleanOneBatch}배치`);
            if (cleanDailyCapacity) configNameParts.push(`${cleanDailyCapacity}캐파`);

            return configNameParts.join('_').replace(/_+/g, '_').replace(/^_|_$/g, ''); // Remove duplicate/leading/trailing underscores
        }

        /**
         * Saves the current working configuration to Firestore.
         * This is called on every relevant input change for real-time sync.
         * The document ID for this is fixed to the user's ID.
         */
        async function saveCurrentWorkingConfig() {
            if (!db || !userId) {
                return; // Firebase not initialized or user ID not available
            }

            try {
                const currentConfig = {
                    processes: processes,
                    productName: productName,
                    selectedFactory: selectedFactory,
                    selectedPackagingType: selectedPackagingType,
                    selectedPackagingUnit: selectedPackagingUnit,
                    selectedSterilizationType: selectedSterilizationType,
                    oneBatchAmount: oneBatchAmount,
                    dailyCapacity: dailyCapacity,
                    productImageUrl: productImageUrl,
                    koreanLabelImageUrl: koreanLabelImageUrl,
                    cookingImageUrl: cookingImageUrl,
                    productImageDescription: productImageDescription,
                    koreanLabelImageDescription: koreanLabelImageDescription,
                    cookingImageDescription: cookingImageDescription,
                    lastUpdated: new Date() // Add a timestamp
                };
                // Store in a specific document for the current user's working session
                const configDocRef = doc(db, "artifacts", appId, "public", "data", "currentWorkingConfigs", userId);
                await setDoc(configDocRef, currentConfig);
                showMessage('현재 작업 내용이 자동으로 저장되었습니다.', 'success');
            } catch (e) {
                console.error("자동 저장 실패:", e);
                // showMessage('자동 저장 실패: ' + e.message, 'error'); // Avoid spamming error for auto-save
            }
        }

        /**
         * Loads the current working configuration from Firestore on app start.
         * Sets up a real-time listener for this document.
         */
        function loadCurrentWorkingConfig() {
            if (!db || !userId) {
                return;
            }
            const configDocRef = doc(db, "artifacts", appId, "public", "data", "currentWorkingConfigs", userId);
            onSnapshot(configDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const configToLoad = docSnap.data();
                    applyConfigToUI(configToLoad);
                    showMessage('이전 작업 내용이 자동으로 불러와졌습니다.', 'info');
                } else {
                    showMessage('새로운 작업이 시작되었습니다. 저장된 내용이 없습니다.', 'info');
                    // Optionally clear UI if no previous working config exists
                    clearUI();
                }
            }, (error) => {
                console.error("현재 작업 구성 로드 실패:", error);
                showMessage('현재 작업 구성 로드에 실패했습니다: ' + error.message, 'error');
            });
        }


        /**
         * Saves the current configuration to Firestore as a named configuration (explicit save button).
         */
        async function saveConfiguration() {
            if (!db || !userId) {
                showMessage('Firebase가 초기화되지 않았거나 사용자 ID가 없습니다. 구성을 저장할 수 없습니다.', 'error');
                return;
            }

            let configName = generateSuggestedConfigName();
            const userProvidedName = prompt(`저장할 구성의 이름을 입력해주세요:`, configName); // Suggest a name
            if (userProvidedName) {
                configName = userProvidedName.trim();
            } else {
                showMessage('구성 저장이 취소되었습니다.', 'info');
                return;
            }

            if (!configName) {
                showMessage('유효한 구성 이름을 입력해주세요.', 'error');
                return;
            }

            try {
                const currentConfig = {
                    processes: processes,
                    productName: productName,
                    selectedFactory: selectedFactory,
                    selectedPackagingType: selectedPackagingType,
                    selectedPackagingUnit: selectedPackagingUnit,
                    selectedSterilizationType: selectedSterilizationType,
                    oneBatchAmount: oneBatchAmount,
                    dailyCapacity: dailyCapacity,
                    productImageUrl: productImageUrl,
                    koreanLabelImageUrl: koreanLabelImageUrl,
                    cookingImageUrl: cookingImageUrl,
                    productImageDescription: productImageDescription,
                    koreanLabelImageDescription: koreanLabelImageDescription,
                    cookingImageDescription: cookingImageDescription,
                    lastUpdated: new Date()
                };

                // Store in a separate collection for explicitly saved configurations
                const configDocRef = doc(db, "artifacts", appId, "public", "data", "savedFlowchartConfigs", configName);
                await setDoc(configDocRef, currentConfig);
                showMessage(`'${configName}' 구성이 Firestore에 저장되었습니다.`, 'success');
            } catch (e) {
                console.error("Firestore 저장 실패:", e);
                showMessage('Firestore 저장에 실패했습니다: ' + e.message, 'error');
            }
        }

        /**
         * Populates the modal with explicitly saved configurations from Firestore.
         */
        async function showLoadConfigModal() {
            if (!db || !userId) {
                showMessage('Firebase가 초기화되지 않았거나 사용자 ID가 없습니다. 구성을 불러올 수 없습니다.', 'error');
                return;
            }
            savedConfigsSelect.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '-- 저장된 구성 선택 --';
            savedConfigsSelect.appendChild(defaultOption);

            try {
                // Only query the collection for explicitly saved configurations
                const configsCollectionRef = collection(db, "artifacts", appId, "public", "data", "savedFlowchartConfigs");
                const q = query(configsCollectionRef);
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    showMessage('저장된 구성이 없습니다.', 'info');
                    // Add a disabled option if no configs are saved
                    const noConfigOption = document.createElement('option');
                    noConfigOption.value = '';
                    noConfigOption.textContent = '저장된 구성 없음';
                    noConfigOption.disabled = true;
                    savedConfigsSelect.appendChild(noConfigOption);
                    loadSelectedConfigBtn.disabled = true;
                    deleteSelectedConfigBtn.disabled = true;
                } else {
                    querySnapshot.forEach(docSnap => {
                        const option = document.createElement('option');
                        option.value = docSnap.id; // Document ID is the config name
                        option.textContent = docSnap.id;
                        savedConfigsSelect.appendChild(option);
                    });
                    loadSelectedConfigBtn.disabled = false;
                    deleteSelectedConfigBtn.disabled = false;
                }

                loadConfigModal.classList.remove('hidden');
            } catch (e) {
                console.error("Firestore 구성 목록 불러오기 실패:", e);
                showMessage('구성 목록 불러오기에 실패했습니다: ' + e.message, 'error');
            }
        }

        /**
         * Applies a loaded configuration object to the UI elements.
         * @param {object} configToLoad - The configuration object to apply.
         */
        function applyConfigToUI(configToLoad) {
            processes = configToLoad.processes ? configToLoad.processes.map(p => ({ ...p, memo: p.memo || '' })) : [];
            productName = configToLoad.productName || '';
            selectedFactory = configToLoad.selectedFactory || '';
            selectedPackagingType = configToLoad.selectedPackagingType || '';
            selectedPackagingUnit = configToLoad.selectedPackagingUnit || '';
            selectedSterilizationType = configToLoad.selectedSterilizationType || '';
            oneBatchAmount = configToLoad.oneBatchAmount || '';
            dailyCapacity = configToLoad.dailyCapacity || '';
            productImageUrl = configToLoad.productImageUrl || '';
            koreanLabelImageUrl = configToLoad.koreanLabelImageUrl || '';
            cookingImageUrl = configToLoad.cookingImageUrl || '';
            productImageDescription = configToLoad.productImageDescription || '';
            koreanLabelImageDescription = configToLoad.koreanLabelImageDescription || '';
            cookingImageDescription = configToLoad.cookingImageDescription || '';

            productNameInput.value = productName;
            factorySelect.value = selectedFactory;
            packagingTypeSelect.value = selectedPackagingType;
            sterilizationTypeSelect.value = selectedSterilizationType;
            oneBatchInput.value = oneBatchAmount;
            dailyCapacityInput.value = dailyCapacity;

            updatePackagingUnitOptions(selectedPackagingType, selectedPackagingUnit); // Correctly set packaging unit

            updateImageDisplay(productImageDisplay, productImageUrlInput, productImageUrl, productImageDropText);
            updateImageDisplay(koreanLabelImageDisplay, koreanLabelImageUrlInput, koreanLabelImageUrl, koreanLabelImageDropText);
            updateImageDisplay(cookingImageDisplay, cookingImageUrlInput, cookingImageUrl, cookingImageDropText);
            productImageDescriptionInput.value = productImageDescription;
            koreanLabelImageDescriptionInput.value = koreanLabelImageDescription;
            cookingImageDescriptionInput.value = cookingImageDescription;

            renderProcessList();
        }

        /**
         * Clears all UI elements to a default empty state.
         */
        function clearUI() {
            processes = [];
            productName = '';
            selectedFactory = '';
            selectedPackagingType = '';
            selectedPackagingUnit = '';
            selectedSterilizationType = '';
            oneBatchAmount = '';
            dailyCapacity = '';
            productImageUrl = '';
            koreanLabelImageUrl = '';
            cookingImageUrl = '';
            productImageDescription = '';
            koreanLabelImageDescription = '';
            cookingImageDescription = '';

            productNameInput.value = '';
            factorySelect.value = '';
            packagingTypeSelect.value = '';
            sterilizationTypeSelect.value = '';
            oneBatchInput.value = '';
            dailyCapacityInput.value = '';

            updatePackagingUnitOptions(''); // Clear packaging unit options
            updateImageDisplay(productImageDisplay, productImageUrlInput, '', productImageDropText);
            updateImageDisplay(koreanLabelImageDisplay, koreanLabelImageUrlInput, '', koreanLabelImageDropText);
            updateImageDisplay(cookingImageDisplay, cookingImageUrlInput, '', cookingImageDropText);
            productImageDescriptionInput.value = '';
            koreanLabelImageDescriptionInput.value = '';
            cookingImageDescriptionInput.value = '';

            renderProcessList(); // Render empty process list
        }


        /**
         * Loads a specific named configuration from Firestore.
         * @param {string} configName - The name of the configuration to load.
         */
        async function loadNamedConfiguration(configName) {
            if (!db || !userId) {
                showMessage('Firebase가 초기화되지 않았거나 사용자 ID가 없습니다. 구성을 불러올 수 없습니다.', 'error');
                return;
            }

            const configDocRef = doc(db, "artifacts", appId, "public", "data", "savedFlowchartConfigs", configName);

            try {
                console.log("getDoc 함수 타입:", typeof getDoc); // 디버깅용 로그 추가
                const docSnap = await getDoc(configDocRef);
                if (docSnap.exists()) {
                    const configToLoad = docSnap.data();
                    applyConfigToUI(configToLoad);
                    showMessage(`'${configName}' 구성을 Firestore에서 불러왔습니다.`, 'success');
                    // After loading a named config, auto-save this state as the new current working config
                    await saveCurrentWorkingConfig();
                } else {
                    showMessage(`'${configName}' 구성을 찾을 수 없거나 삭제되었습니다.`, 'error');
                }
            } catch (e) {
                console.error("Firestore 데이터 로드 실패:", e);
                showMessage('Firestore 데이터 로드에 실패했습니다: ' + e.message, 'error');
            }
        }


        /**
         * Deletes a specific named configuration from Firestore.
         * @param {string} configName - The name of the configuration to delete.
         */
        async function deleteNamedConfiguration(configName) {
            if (!db || !userId) {
                showMessage('Firebase가 초기화되지 않았거나 사용자 ID가 없습니다. 구성을 삭제할 수 없습니다.', 'error');
                return;
            }

            try {
                const configDocRef = doc(db, "artifacts", appId, "public", "data", "savedFlowchartConfigs", configName);
                await deleteDoc(configDocRef);
                showMessage(`'${configName}' 구성이 Firestore에서 삭제되었습니다.`, 'success');
                showLoadConfigModal(); // Refresh the list in the modal

                // If the deleted config was the one currently being edited, clear the UI
                const currentIdentifier = generateSuggestedConfigName(); // Use suggested name for comparison
                if (currentIdentifier === configName) {
                    clearUI();
                    await saveCurrentWorkingConfig(); // Save empty state as current working config
                }

            } catch (e) {
                console.error("Firestore 삭제 실패:", e);
                showMessage('구성 삭제에 실패했습니다: ' + e.message, 'error');
            }
        }


        /**
         * Exports the entire content area as an image.
         */
        function exportFlowchartAsImage() {
            const elementsToHide = [
                productImageUrlInput, cookingImageUrlInput, koreanLabelImageUrlInput,
                productImageDropText, cookingImageDropText, koreanLabelImageDropText,
                productImageUrlLabel, cookingImageUrlLabel, koreanLabelImageUrlLabel
            ];
            const memoTextareas = document.querySelectorAll('#process-list textarea');

            // Temporarily hide elements and memo textareas
            elementsToHide.forEach(el => el.classList.add('hidden'));
            memoTextareas.forEach(el => el.classList.add('hidden'));

            const contentToCapture = document.getElementById('main-content-area');

            html2canvas(contentToCapture, {
                backgroundColor: '#ffffff',
                scale: 2
            }).then(canvas => {
                // Restore visibility
                elementsToHide.forEach(el => el.classList.remove('hidden'));
                memoTextareas.forEach(el => el.classList.remove('hidden'));

                const imageUrl = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = imageUrl;

                let fileNameParts = [];
                if (selectedFactory) fileNameParts.push(selectedFactory);
                if (productName) fileNameParts.push(productName);
                if (selectedPackagingType) fileNameParts.push(selectedPackagingType);
                if (selectedPackagingUnit) fileNameParts.push(selectedPackagingUnit);
                if (selectedSterilizationType) fileNameParts.push(selectedSterilizationType);
                const cleanOneBatch = oneBatchAmount.replace(/[^a-zA-Z0-9가-힣]/g, '').trim();
                const cleanDailyCapacity = dailyCapacity.replace(/[^a-zA-Z0-9가-힣]/g, '').trim();
                if (cleanOneBatch) fileNameParts.push(`${cleanOneBatch}배치`);
                if (cleanDailyCapacity) fileNameParts.push(`${cleanDailyCapacity}캐파`);

                let fileName = 'flowchart.png';
                if (fileNameParts.length > 0) {
                    fileName = `${fileNameParts.join('_')}_flowchart.png`;
                }
                
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                showMessage(`플로우 차트 이미지가 '${fileName}'으로 다운로드됩니다.`, 'success');
            }).catch(error => {
                // Ensure elements are unhidden even if an error occurs
                elementsToHide.forEach(el => el.classList.remove('hidden'));
                memoTextareas.forEach(el => el.classList.remove('hidden'));
                console.error("이미지 내보내기 오류:", error);
                showMessage('이미지 내보내기에 실패했습니다: ' + error.message, 'error');
            });
        }

        /**
         * Displays a status message to the user.
         * @param {string} message - The message to display.
         * @param {'success'|'error'|'info'} type - The type of message.
         */
        function showMessage(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = 'text-sm text-center mt-2 font-medium ';
            if (type === 'success') {
                statusMessage.classList.add('text-green-600');
            } else if (type === 'error') {
                statusMessage.classList.add('text-red-600');
            } else { // info
                statusMessage.classList.add('text-blue-600');
            }
            setTimeout(() => {
                statusMessage.textContent = '';
                statusMessage.className = 'text-sm text-center mt-2 text-gray-600';
            }, 3000);
        }

        /**
         * Helper function to update image display and visibility of drop text.
         * @param {HTMLImageElement} imgElement - The <img> element to update.
         * @param {HTMLInputElement} urlInput - The <input> element for the URL.
         * @param {string} imageUrl - The new image URL (or Base64 string).
         * @param {HTMLElement} dropTextElement - The <p> element for the drop text.
         */
        function updateImageDisplay(imgElement, urlInput, imageUrl, dropTextElement) {
            imgElement.src = imageUrl || imgElement.dataset.placeholderSrc;
            urlInput.value = imageUrl;
            if (imageUrl && imageUrl !== imgElement.dataset.placeholderSrc) {
                dropTextElement.classList.add('hidden');
            } else {
                dropTextElement.classList.remove('hidden');
            }
        }

        // --- Drag and Drop Logic for Processes ---

        function handleDragStart(e) {
            draggedItem = this; // 'this' refers to the li element
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.id);
            setTimeout(() => {
                this.classList.add('dragging');
            }, 0);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const target = e.target.closest('li');
            if (target && target !== draggedItem) {
                target.classList.add('border-blue-500');
            }
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const target = e.target.closest('li');
            if (target && target !== draggedItem) {
                // target.classList.add('bg-blue-100');
            }
        }

        function handleDragLeave(e) {
            const target = e.target.closest('li');
            if (target) {
                target.classList.remove('border-blue-500');
                // target.classList.remove('bg-blue-100');
            }
        }

        async function handleDrop(e) { // Make async to await Firestore save
            e.preventDefault();
            const targetItem = this; // 'this' refers to the li element where the drop occurred
            targetItem.classList.remove('border-blue-500');

            if (draggedItem === targetItem) {
                return;
            }

            const draggedId = parseInt(draggedItem.id.replace('process-', ''));
            const targetId = parseInt(targetItem.id.replace('process-', ''));

            const draggedIndex = processes.findIndex(p => p.id === draggedId);
            const targetIndex = processes.findIndex(p => p.id === targetId);

            if (draggedIndex === -1 || targetIndex === -1) return;

            const [removed] = processes.splice(draggedIndex, 1);
            processes.splice(targetIndex, 0, removed);

            renderProcessList();
            await saveCurrentWorkingConfig(); // Save to Firestore after reordering
            showMessage('공정 순서가 변경되었습니다.', 'info');
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            draggedItem = null;
            document.querySelectorAll('#process-list li').forEach(li => {
                li.classList.remove('border-blue-500', 'bg-blue-100');
            });
        }

        // --- Drag and Drop Logic for Images ---

        function handleImageDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('border-blue-500', 'bg-blue-50');
        }

        function handleImageDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('border-blue-500', 'bg-blue-50');
        }

        async function handleImageDrop(e) { // Make async to await Firestore save
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('border-blue-500', 'bg-blue-50');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = async (event) => { // Make async to await Firestore save
                        const imageDataUrl = event.target.result;
                        if (this.id === 'product-image-drop-zone') {
                            productImageUrl = imageDataUrl;
                            updateImageDisplay(productImageDisplay, productImageUrlInput, productImageUrl, productImageDropText);
                        } else if (this.id === 'korean-label-image-drop-zone') {
                            koreanLabelImageUrl = imageDataUrl;
                            updateImageDisplay(koreanLabelImageDisplay, koreanLabelImageUrlInput, koreanLabelImageUrl, koreanLabelImageDropText);
                        } else if (this.id === 'cooking-image-drop-zone') {
                            cookingImageUrl = imageDataUrl;
                            updateImageDisplay(cookingImageDisplay, cookingImageUrlInput, cookingImageUrl, cookingImageDropText);
                        }
                        await saveCurrentWorkingConfig(); // Save to Firestore after image drop
                        showMessage('이미지가 성공적으로 추가되었습니다.', 'success');
                    };
                    reader.onerror = () => {
                        showMessage('이미지 파일을 읽는 데 실패했습니다.', 'error');
                    };
                    reader.readAsDataURL(file);
                } else {
                    showMessage('이미지 파일만 드롭할 수 있습니다.', 'error');
                }
            }
        }
        
        // Expose functions to the global scope so they can be called from HTML attributes
        window.addProcess = addProcess;
        window.saveConfiguration = saveConfiguration;
        window.showLoadConfigModal = showLoadConfigModal;
        window.exportFlowchartAsImage = exportFlowchartAsImage;
        window.updateFlowchartColors = updateFlowchartColors; 
        window.toggleProcess = toggleProcess;
        window.deleteProcess = deleteProcess;
        window.makeEditable = makeEditable; 
    </script>
</body>
</html>
